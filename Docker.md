# Docker

![alt text](https://www.docker.com/wp-content/uploads/2022/03/horizontal-logo-monochromatic-white.png "Docker")

- [Docker](#docker)
  - [Cheatsheet](#cheatsheet)
    - [Common](#common)
    - [Run](#run)
    - [Build](#build)
    - [Image](#image)
  - [Basics](#basics)

<br>
<br>

## Cheatsheet
This will have some quick commands to reference. 

### Common
| Command | Description |
| --- | --- |
| `docker version` | Check the version of docker client and server(daemon) and if they are talking |
| `docker info` | Get all of the docker engine and configuration info |
| `docker container run <OPTIONS> <IMAGE:TAG(optional)>` | Simply run a Docker container |
| `docker container ls` | List all **running** containers. Add `-a` to see **unremoved stopped containers** |
| `docker container stop <ID/NAME>` | Stop a container. You can also just use the first few characters of an ID to stop it as long as it it unique from the others |
| `docker container logs <CONTAINER>` | Get the last few lines generated by **all** logs |
| `docker container top <CONTAINER>` | Get the current running processes on a container |
| `docker container inspect <CONTAINER>` | Get the details of how a container is configured as JSON |
| `docker container stats` | Get performance stats on **all** containers in a real-time stream (You can also specify a container name) |
| `docker container start -ai <CONTAINER>` | Similar to the run command with `-it` but used on a **stopped** container |
| `docker container exec <CONTAINER> <COMMAND>` | Execute a command from within a container. If the container is running an application, you dont need to start the application first |
| `docker container exec -it <CONTAINER> bash | Run an interactive bash from within a **running** container. Useful for containers that run an application |

### Run
| Command | Description |
| --- | --- |
| `docker container run <OPTIONS> <IMAGE:TAG(optional)>` | Simply run a Docker container |
| Option `-it` | When container starts, launch an interactive terminal (`i` Interactive `t` simulate TTY). (**container shuts down when you exit**) |
| Option `--rm` | Delete the container when it stops |
| Option `-p <LOCALPORT>:<CONTAINERPORT>` | Expose a port within the container (if local port is used you will get an error) |
| Option `--detatch/-d` | Run the container in the background of the terminal session |
| Option `--name <NAME>` | Specifiy a container name |

### Build
| Command | Description |
| --- | --- |


### Image
| Command | Description |
| --- | --- |


<br>
<br>

## Basics
* **Image** - Binaries, libraries, and source code used that make up the application
* **Container** - Instance of an image that is currently running a process
* **Registry** - Repository of images that is remote (but you can make a server if wanted)
* When you dont have an image specified, docker will always download it locally
* Each time you run a container you get a unique alp/num container ID
* Every time docker runs a container a new instance will be created and will stay on the system until removed
* Docker also generates the container name unless you tell it otherwise
* Docker images work off of **layers**. If a layer already exists between different versions of an image or even between images, Docker will instead download the layer that is needed
* Docker containers are given a virtual IP on a private network w/n the engine
* When a application image is ran (postgres, httpd, nginx) by default it executes the command needed to run, and will continue to run unless you specify for it to stop. 
  * When you do a `-it` the command is switched to a shell and if you exit the container will stop
* If a container is running an application, simply attatching a session to it will only execute commands within that application
  * i.e. a postgres container will already be running the postres *commandline session*, so you cant run commands like `/bin/systemctl status postgresql` but you **can** run `\l` which is a postgres commandline meta-command